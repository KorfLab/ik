/******************************************************************************\
align.c

Copyright (C) 2003-2006 Ian Korf

\******************************************************************************/

#ifndef IK_ALIGN_C
#define IK_ALIGN_C

#include "align.h"
#include "toolbox.h"

static int NT[25][25] = {
	{1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
	{-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
	{-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
	{-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
	{-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
	{-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
	{-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1,-1},
	{-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1,1}
};

static int B40[25][25] = {
	{5,0,-2,-1,-1,-3,1,-2,-1,0,-1,-2,-1,-1,0,-2,0,-2,1,0,0,0,-3,0,-2},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{-2,0,16,-2,-2,-2,-3,-4,-4,0,-3,-2,-3,-2,0,-5,-4,-3,-1,-1,0,-2,-6,-2,-4},
	{-1,0,-2,9,2,-4,-2,0,-4,0,0,-3,-3,2,0,-2,-1,-1,0,-1,0,-3,-5,-1,-3},
	{-1,0,-2,2,7,-3,-3,0,-4,0,1,-2,-2,-1,0,0,2,-1,0,-1,0,-3,-2,-1,-2},
	{-3,0,-2,-4,-3,9,-3,-2,1,0,-3,2,0,-3,0,-4,-4,-2,-2,-1,0,0,1,-1,4},
	{1,0,-3,-2,-3,-3,8,-2,-4,0,-2,-4,-2,0,0,-1,-2,-3,0,-2,0,-4,-2,-1,-3},
	{-2,0,-4,0,0,-2,-2,13,-3,0,-1,-2,1,1,0,-2,0,0,-1,-2,0,-4,-5,-1,2},
	{-1,0,-4,-4,-4,1,-4,-3,6,0,-3,2,1,-2,0,-2,-3,-3,-2,-1,0,4,-3,-1,0},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{-1,0,-3,0,1,-3,-2,-1,-3,0,6,-2,-1,0,0,-1,1,3,0,0,0,-2,-2,-1,-1},
	{-2,0,-2,-3,-2,2,-4,-2,2,0,-2,6,3,-3,0,-4,-2,-2,-3,-1,0,2,-1,-1,0},
	{-1,0,-3,-3,-2,0,-2,1,1,0,-1,3,7,-2,0,-2,-1,-1,-2,-1,0,1,-2,0,1},
	{-1,0,-2,2,-1,-3,0,1,-2,0,0,-3,-2,8,0,-2,1,0,1,0,0,-3,-4,-1,-2},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{-2,0,-5,-2,0,-4,-1,-2,-2,0,-1,-4,-2,-2,0,11,-2,-3,-1,0,0,-3,-4,-2,-3},
	{0,0,-4,-1,2,-4,-2,0,-3,0,1,-2,-1,1,0,-2,8,2,1,-1,0,-3,-1,-1,-1},
	{-2,0,-3,-1,-1,-2,-3,0,-3,0,3,-2,-1,0,0,-3,2,9,-1,-2,0,-2,-2,-1,-1},
	{1,0,-1,0,0,-2,0,-1,-2,0,0,-3,-2,1,0,-1,1,-1,5,2,0,-1,-5,0,-2},
	{0,0,-1,-1,-1,-1,-2,-2,-1,0,0,-1,-1,0,0,0,-1,-2,2,6,0,1,-4,0,-1},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,-2,-3,-3,0,-4,-4,4,0,-2,2,1,-3,0,-3,-3,-2,-1,1,0,5,-3,-1,-1},
	{-3,0,-6,-5,-2,1,-2,-5,-3,0,-2,-1,-2,-4,0,-4,-1,-2,-5,-4,0,-3,19,-2,3},
	{0,0,-2,-1,-1,-1,-1,-1,-1,0,-1,-1,0,-1,0,-2,-1,-1,0,0,0,-1,-2,-1,-1},
	{-2,0,-4,-3,-2,4,-3,2,0,0,-1,0,1,-2,0,-3,-1,-1,-2,-1,0,-1,3,-1,9},
};

static int B62[25][25] = {
	{4,0,0,-2,-1,-2,0,-2,-1,0,-1,-1,-1,-2,0,-1,-1,-1,1,0,0,0,-3,0,-2},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,9,-3,-4,-2,-3,-3,-1,0,-3,-1,-1,-3,0,-3,-3,-3,-1,-1,0,-1,-2,-2,-2},
	{-2,0,-3,6,2,-3,-1,-1,-3,0,-1,-4,-3,1,0,-1,0,-2,0,-1,0,-3,-4,-1,-3},
	{-1,0,-4,2,5,-3,-2,0,-3,0,1,-3,-2,0,0,-1,2,0,0,-1,0,-2,-3,-1,-2},
	{-2,0,-2,-3,-3,6,-3,-1,0,0,-3,0,0,-3,0,-4,-3,-3,-2,-2,0,-1,1,-1,3},
	{0,0,-3,-1,-2,-3,6,-2,-4,0,-2,-4,-3,0,0,-2,-2,-2,0,-2,0,-3,-2,-1,-3},
	{-2,0,-3,-1,0,-1,-2,8,-3,0,-1,-3,-2,1,0,-2,0,0,-1,-2,0,-3,-2,-1,2},
	{-1,0,-1,-3,-3,0,-4,-3,4,0,-3,2,1,-3,0,-3,-3,-3,-2,-1,0,3,-3,-1,-1},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{-1,0,-3,-1,1,-3,-2,-1,-3,0,5,-2,-1,0,0,-1,1,2,0,-1,0,-2,-3,-1,-2},
	{-1,0,-1,-4,-3,0,-4,-3,2,0,-2,4,2,-3,0,-3,-2,-2,-2,-1,0,1,-2,-1,-1},
	{-1,0,-1,-3,-2,0,-3,-2,1,0,-1,2,5,-2,0,-2,0,-1,-1,-1,0,1,-1,-1,-1},
	{-2,0,-3,1,0,-3,0,1,-3,0,0,-3,-2,6,0,-2,0,0,1,0,0,-3,-4,-1,-2},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{-1,0,-3,-1,-1,-4,-2,-2,-3,0,-1,-3,-2,-2,0,7,-1,-2,-1,-1,0,-2,-4,-2,-3},
	{-1,0,-3,0,2,-3,-2,0,-3,0,1,-2,0,0,0,-1,5,1,0,-1,0,-2,-2,-1,-1},
	{-1,0,-3,-2,0,-3,-2,0,-3,0,2,-2,-1,0,0,-2,1,5,-1,-1,0,-3,-3,-1,-2},
	{1,0,-1,0,0,-2,0,-1,-2,0,0,-2,-1,1,0,-1,0,-1,4,1,0,-2,-3,0,-2},
	{0,0,-1,-1,-1,-2,-2,-2,-1,0,-1,-1,-1,0,0,-1,-1,-1,1,5,0,0,-2,0,-2},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{0,0,-1,-3,-2,-1,-3,-3,3,0,-2,1,1,-3,0,-2,-2,-3,-2,0,0,4,-3,-1,-1},
	{-3,0,-2,-4,-3,1,-2,-2,-3,0,-3,-2,-1,-4,0,-4,-2,-3,-3,-2,0,-3,11,-2,2},
	{0,0,-2,-1,-1,-1,-1,-1,-1,0,-1,-1,-1,-1,0,-2,-1,-1,0,0,0,-1,-2,-1,-1},
	{-2,0,-2,-3,-2,3,-3,2,-1,0,-2,-1,-1,-2,0,-3,-1,-2,-2,-2,0,-1,2,-1,7},
};

static int B80[25][25] = {
	{7,0,-1,-3,-2,-4,0,-3,-3,0,-1,-3,-2,-3,0,-1,-2,-3,2,0,0,-1,-5,-1,-4},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{-1,0,13,-7,-7,-4,-6,-7,-2,0,-6,-3,-3,-5,0,-6,-5,-6,-2,-2,0,-2,-5,-4,-5},
	{-3,0,-7,10,2,-6,-3,-2,-7,0,-2,-7,-6,2,0,-3,-1,-3,-1,-2,0,-6,-8,-3,-6},
	{-2,0,-7,2,8,-6,-4,0,-6,0,1,-6,-4,-1,0,-2,3,-1,-1,-2,0,-4,-6,-2,-5},
	{-4,0,-4,-6,-6,10,-6,-2,-1,0,-5,0,0,-6,0,-6,-5,-5,-4,-4,0,-2,0,-3,4},
	{0,0,-6,-3,-4,-6,9,-4,-7,0,-3,-7,-5,-1,0,-5,-4,-4,-1,-3,0,-6,-6,-3,-6},
	{-3,0,-7,-2,0,-2,-4,12,-6,0,-1,-5,-4,1,0,-4,1,0,-2,-3,0,-5,-4,-2,3},
	{-3,0,-2,-7,-6,-1,-7,-6,7,0,-5,2,2,-6,0,-5,-5,-5,-4,-2,0,4,-5,-2,-3},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{-1,0,-6,-2,1,-5,-3,-1,-5,0,8,-4,-3,0,0,-2,2,3,-1,-1,0,-4,-6,-2,-4},
	{-3,0,-3,-7,-6,0,-7,-5,2,0,-4,6,3,-6,0,-5,-4,-4,-4,-3,0,1,-4,-2,-2},
	{-2,0,-3,-6,-4,0,-5,-4,2,0,-3,3,9,-4,0,-4,-1,-3,-3,-1,0,1,-3,-2,-3},
	{-3,0,-5,2,-1,-6,-1,1,-6,0,0,-6,-4,9,0,-4,0,-1,1,0,0,-5,-7,-2,-4},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{-1,0,-6,-3,-2,-6,-5,-4,-5,0,-2,-5,-4,-4,0,12,-3,-3,-2,-3,0,-4,-7,-3,-6},
	{-2,0,-5,-1,3,-5,-4,1,-5,0,2,-4,-1,0,0,-3,9,1,-1,-1,0,-4,-4,-2,-3},
	{-3,0,-6,-3,-1,-5,-4,0,-5,0,3,-4,-3,-1,0,-3,1,9,-2,-2,0,-4,-5,-2,-4},
	{2,0,-2,-1,-1,-4,-1,-2,-4,0,-1,-4,-3,1,0,-2,-1,-2,7,2,0,-3,-6,-1,-3},
	{0,0,-2,-2,-2,-4,-3,-3,-2,0,-1,-3,-1,0,0,-3,-1,-2,2,8,0,0,-5,-1,-3},
	{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
	{-1,0,-2,-6,-4,-2,-6,-5,4,0,-4,1,1,-5,0,-4,-4,-4,-3,0,0,7,-5,-2,-3},
	{-5,0,-5,-8,-6,0,-6,-4,-5,0,-6,-4,-3,-7,0,-7,-4,-5,-6,-5,0,-5,16,-5,3},
	{-1,0,-4,-3,-2,-3,-3,-2,-2,0,-2,-2,-2,-2,0,-3,-2,-2,-1,-1,0,-2,-5,-2,-3},
	{-4,0,-5,-6,-5,4,-6,3,-3,0,-4,-2,-3,-4,0,-6,-3,-4,-3,-3,0,-3,3,-3,11},
};

static int Matrix = -1;
static int MAT[25][25];
static int GAP;

void set_matrix (int N) {
	int i, j;
	
	if (Matrix == N) return;
	Matrix = N;
	
	if (N == 40) {
		for (i = 0; i < 25; i++) for (j = 0; j < 25; j++) MAT[i][j] = B40[i][j];
		GAP = -4;
	} else if (N == 62) {
		for (i = 0; i < 25; i++) for (j = 0; j < 25; j++) MAT[i][j] = B62[i][j];
		GAP = -5;
	} else if (N == 80) {
		for (i = 0; i < 25; i++) for (j = 0; j < 25; j++) MAT[i][j] = B80[i][j];
		GAP = -7;
	} else if (N == 0) {
		for (i = 0; i < 25; i++) for (j = 0; j < 25; j++) MAT[i][j] = NT[i][j];
		GAP = -2;
	} else {
		ik_exit(1, "invalid matrix identifier");
	}
	
}

ik_align sw_mmg (const char *s1, const char *s2, int m, int n, int g) {
	int i, j, l1, l2, max_i, max_j, min_i, min_j;
	double d, v, h, max_s = 0;
	double ** sm;
	char ** tm;
	ik_ivec a1, a2, a3;
	ik_align align = malloc(sizeof(struct _ik_align));
	
	l1 = strlen(s1), l2 = strlen(s2);
	
	/* allocate matrices */
	sm = malloc(sizeof(double*) * (l1+1));
	tm = malloc(sizeof(double*) * (l1+1));
	for (i = 0; i <= l1; i++)  sm[i] = malloc(sizeof(double) * (l2+1));
	for (i = 0; i <= l1; i++)  tm[i] = malloc(sizeof(double) * (l2+1));
		
	/* init first column and row */
	for (i = 0; i <= l1; i++) sm[i][0] = 0, tm[i][0] = '.';
	for (j = 1; j <= l2; j++) sm[0][j] = 0, tm[0][j] = '.';
	
	/* fill matrix */
	for (i = 1; i <= l1; i++) {
		for (j = 1; j <= l2; j++) {
			if (s1[i-1] == s2[j-1]) d = sm[i-1][j-1] + m;
			else                    d = sm[i-1][j-1] + n;
			v = sm[i-1][j] + g;
			h = sm[i][j-1] + g;
			
			if (d > h && d > v && d > 0) sm[i][j] = d, tm[i][j] = 'd';
			else if (h > v && h > 0)     sm[i][j] = h, tm[i][j] = 'h';
			else if (v > 0)              sm[i][j] = v, tm[i][j] = 'v';
			else                         sm[i][j] = 0, tm[i][j] = '.';
			
			if (d > max_s) max_s = d, max_i = i, max_j = j;
		}
	}
	
	/* traceback */
	a1 = ik_ivec_new();
	a2 = ik_ivec_new();
	a3 = ik_ivec_new();
	i = max_i, j = max_j;
	while (sm[i][j] > 0) {
		min_i = i;
		min_j = j;
		
		if (tm[i][j] == 'd') {
			ik_ivec_push(a1, s1[i-1]);
			ik_ivec_push(a2, s2[j-1]);
			if (s1[i-1] == s2[j-1]) {
				ik_ivec_push(a3, '+');
			} else {
				ik_ivec_push(a3, '-');
			}
			i--;
			j--;
		} else if (tm[i][j] == 'h') {
			ik_ivec_push(a2, s2[j-1]);
			ik_ivec_push(a1, '-');
			ik_ivec_push(a3, 'h');
			j--;
		} else if (tm[i][j] == 'v') {
			ik_ivec_push(a1, s1[i-1]);
			ik_ivec_push(a2, '-');
			ik_ivec_push(a3, 'v');
			i--;
		}
	}
	
	/* set alignment properties */
	align->score = max_s;
	align->s1_beg = min_i;
	align->s1_end = max_i;
	align->s2_beg = min_j;
	align->s2_end = max_j;
	
	j = a1->size + 1;
	align->s1_seq    = malloc(j);
	align->s2_seq    = malloc(j);
	align->alignment = malloc(j);
		
	for (i = j-1; i >= 0; i--) align->s1_seq[i]    = a1->elem[i];
	for (i = j-1; i >= 0; i--) align->s2_seq[i]    = a2->elem[i];
	for (i = j-1; i >= 0; i--) align->alignment[i] = a3->elem[i];
	
	align->s1_seq[j-1]    = '\0';
	align->s2_seq[j-1]    = '\0';
	align->alignment[j-1] = '\0';
	
//	printf("%s\n%s\n%s\n", align->s1_seq, align->alignment, align->s2_seq);

	/* clean up */
	ik_ivec_free(a1);
	ik_ivec_free(a2);
	ik_ivec_free(a3);
	for (i = 0; i <= l1; i++) {
		free(sm[i]);
		free(tm[i]);
	}
	free(sm);
	free(tm);
	
	return align;
}

ik_align sw_mat (const char *s1, const char *s2, int blosum) {
	int i, j, l1, l2, max_i, max_j, min_i, min_j;
	double d, v, h, max_s = 0;
	double ** sm;
	char ** tm;
	int a, b;
	ik_ivec a1, a2, a3;
	ik_align align = malloc(sizeof(struct _ik_align));
	
	l1 = strlen(s1), l2 = strlen(s2);
	set_matrix(blosum);
	
	/* allocate matrices */
	sm = malloc(sizeof(double*) * (l1+1));
	tm = malloc(sizeof(double*) * (l1+1));
	for (i = 0; i <= l1; i++)  sm[i] = malloc(sizeof(double) * (l2+1));
	for (i = 0; i <= l1; i++)  tm[i] = malloc(sizeof(double) * (l2+1));
		
	/* init first column and row */
	for (i = 0; i <= l1; i++) sm[i][0] = 0, tm[i][0] = '.';
	for (j = 1; j <= l2; j++) sm[0][j] = 0, tm[0][j] = '.';
	
	/* fill matrix */
	for (i = 1; i <= l1; i++) {
		for (j = 1; j <= l2; j++) {
			a = s1[i-1] - 'A';
			b = s2[j-1] - 'A';
			if (a >= 25) ik_exit(1, "fatal flaw a25 %d\n", a);
			if (b >= 25) ik_exit(1, "fatal flaw b25 %d\n", a);
			
			d = sm[i-1][j-1] + MAT[a][b];
			v = sm[i-1][j  ] + GAP;
			h = sm[i  ][j-1] + GAP;
			
			if (d > h && d > v && d > 0) sm[i][j] = d, tm[i][j] = 'd';
			else if (h > v && h > 0)     sm[i][j] = h, tm[i][j] = 'h';
			else if (v > 0)              sm[i][j] = v, tm[i][j] = 'v';
			else                         sm[i][j] = 0, tm[i][j] = '.';
			
			if (d > max_s) max_s = d, max_i = i, max_j = j;
		}
	}
	
	/* traceback */
	a1 = ik_ivec_new();
	a2 = ik_ivec_new();
	a3 = ik_ivec_new();
	i = max_i, j = max_j;
	while (sm[i][j] > 0) {
		min_i = i;
		min_j = j;
		
		if (tm[i][j] == 'd') {
			ik_ivec_push(a1, s1[i-1]);
			ik_ivec_push(a2, s2[j-1]);
			if (s1[i-1] == s2[j-1]) {
				ik_ivec_push(a3, '|');
			} else {
				ik_ivec_push(a3, '.');
			}
			i--;
			j--;
		} else if (tm[i][j] == 'h') {
			ik_ivec_push(a2, s2[j-1]);
			ik_ivec_push(a1, '-');
			ik_ivec_push(a3, 'h');
			j--;
		} else if (tm[i][j] == 'v') {
			ik_ivec_push(a1, s1[i-1]);
			ik_ivec_push(a2, '-');
			ik_ivec_push(a3, 'v');
			i--;
		}
	}
	
	/* set alignment properties */
	align->score  = max_s;
	align->s1_beg = min_i;
	align->s1_end = max_i;
	align->s2_beg = min_j;
	align->s2_end = max_j;
		
	j = a1->size + 1;
	align->s1_seq    = malloc(j);
	align->s2_seq    = malloc(j);
	align->alignment = malloc(j);
		
	for (i = j-1; i >= 0; i--) align->s1_seq[i]    = a1->elem[i];
	for (i = j-1; i >= 0; i--) align->s2_seq[i]    = a2->elem[i];
	for (i = j-1; i >= 0; i--) align->alignment[i] = a3->elem[i];
	
	align->s1_seq[j-1]    = '\0';
	align->s2_seq[j-1]    = '\0';
	align->alignment[j-1] = '\0';
	
//	printf("%s\n%s\n%s\n", align->s1_seq, align->alignment, align->s2_seq);

	/* clean up */
	ik_ivec_free(a1);
	ik_ivec_free(a2);
	ik_ivec_free(a3);
	for (i = 0; i <= l1; i++) {
		free(sm[i]);
		free(tm[i]);
	}
	free(sm);
	free(tm);
	
	return align;
}

double sw_mmg_linear (const char *s1, const char *s2, int m, int n, int g) {
	int i, j, k, l1, l2, max_i, max_j;
	double d, v, h, max_s = 0;
	double *r1, *r2;
		
	/* init */
	l1 = strlen(s1);
	l2 = strlen(s2);
	r1 = malloc(sizeof(double) * l2 + 1);
	r2 = malloc(sizeof(double) * l2 + 1);
	for (j = 0; j <= l2; j++) r1[j] = 0;
	r2[0] = 0;
	
	/* fill */
	for (i = 1; i <= l1; i++) {
		for (j = 1; j <= l2; j++) {
			if (s1[i-1] == s2[j-1]) d = r1[j-1] + m;
			else                    d = r1[j-1] + n;
			h = r1[j] + g;
			v = r2[j-1] + g;
						
			if      (d > h && d > v && d > 0) r2[j] = d;
			else if (h > v && h > 0)          r2[j] = h;
			else if (v > 0)                   r2[j] = v;
			else                              r2[j] = 0;
			
			if (d > max_s) max_s = d, max_i = i, max_j = j;
		}
		
		/* copy row 2 to row 1*/
		for (k = 0; k <= l2; k++) r1[k] = r2[k];
		r2[0] = 0;
	}
			
	/* clean up */
	free(r1);
	free(r2);
	
	return max_s;
}

double sw_mat_linear (const char *s1, const char *s2, int blosum) {
	int i, j, k, l1, l2, max_i, max_j, a, b;
	double d, v, h, max_s = 0;
	double *r1, *r2;
		
	/* init */
	l1 = strlen(s1);
	l2 = strlen(s2);
	set_matrix(blosum);
	r1 = malloc(sizeof(double) * l2 + 1);
	r2 = malloc(sizeof(double) * l2 + 1);
	for (j = 0; j <= l2; j++) r1[j] = 0;
	r2[0] = 0;

	/* fill */
	for (i = 1; i <= l1; i++) {
		for (j = 1; j <= l2; j++) {
			a = s1[i-1] - 'A';
			b = s2[j-1] - 'A';
			d = r1[j-1] + MAT[a][b];
			h = r1[j] + GAP;
			v = r2[j-1] + GAP;
						
			if      (d > h && d > v && d > 0) r2[j] = d;
			else if (h > v && h > 0)          r2[j] = h;
			else if (v > 0)                   r2[j] = v;
			else                              r2[j] = 0;
			
			if (d > max_s) max_s = d, max_i = i, max_j = j;
		}
		
		/* copy row 2 to row 1*/
		for (k = 0; k <= l2; k++) r1[k] = r2[k];
		r2[0] = 0;
	}
			
	/* clean up */
	free(r1);
	free(r2);
	
	return max_s;
}

void ik_align_free (ik_align a) {
	free(a->s1_seq);
	free(a->s2_seq);
	free(a->alignment);
	free(a);
}

#endif
